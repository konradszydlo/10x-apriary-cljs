# Docker Deployment Guide

This guide explains how to build and run the Apiary application using Docker.

This Dockerfile follows [Biff framework](https://biffweb.com/) best practices for containerized deployment.

## Prerequisites

- Docker installed on your system
- Docker Compose installed (usually comes with Docker Desktop)

**Note:** The `config.env.example` file is already configured with autogenerated secrets suitable for local development. No additional setup needed for local use!

## Architecture

This Docker setup follows Biff framework best practices (similar to `server-setup.sh`) with performance optimizations:

### **Caddy Reverse Proxy**
- Serves static files (CSS, JS, images) directly without hitting the Clojure app
- Automatically handles HTTPS with Let's Encrypt in production
- Enables gzip/zstd compression for text assets
- Sets cache headers for static files (1-year immutable cache)
- Proxies dynamic requests to the app on port 8080

### **Static File Strategy**
Mirrors the nginx config from `server-setup.sh`:
1. Caddy first tries to serve from `/var/www/public` (static files)
2. If not found, proxies the request to the Clojure app
3. App generates files to `target/resources/public` (takes priority)
4. Falls back to `resources/public` for base assets

This approach significantly reduces a load on the Clojure app by serving static assets at the reverse proxy layer.

## Quick Start

### Using Docker Compose (Recommended)

1. **Check your `config.env` file:**

   The `config.env` file should already have autogenerated secrets. For local development, you can use the existing values as-is:

   ```bash
   DOMAIN=localhost
   COOKIE_SECRET=OJOFZx2rgIw+SQ6BY7h2kQ==  # âœ“ Already set
   ```

   **For production**, you should generate a new secret (see "Generating New Secrets" section below).

2. **Build and start the application:**
   ```bash
   docker compose up -d
   ```

3. **Access the application:**

   The application is now available with HTTPS support:
   - **HTTPS:** https://localhost (recommended)
   - **HTTP:** http://localhost (auto-redirects to HTTPS)

   **Note:** You'll see a browser security warning because Caddy uses self-signed certificates for localhost. This is normal and safe for local development. Click "Advanced" and "Proceed to localhost" to continue.

4. **View logs:**
   ```bash
   docker compose logs -f app
   ```

5. **Stop the application:**
   ```bash
   docker compose down
   ```

6. **Stop and remove all data:**
   ```bash
   docker compose down -v
   ```

### Using Docker CLI

1. **Build the Docker image:**
   ```bash
   docker build -t apiary-app:latest .
   ```

2. **Run the container:**
   ```bash
   docker run -d \
     --name apiary-app \
     -p 8080:8080 \
     --env-file config.env \
     -e BIFF_PROFILE=prod \
     -e HOST=0.0.0.0 \
     -e PORT=8080 \
     -v xtdb-data:/app/storage \
     apiary-app:latest
   ```

3. **View logs:**
   ```bash
   docker logs -f apiary-app
   ```

4. **Stop and remove the container:**
   ```bash
   docker stop apiary-app
   docker rm apiary-app
   ```

## Configuration

### Environment Variables

The application uses environment variables defined in `config.env`.

#### Required Variables:

- `DOMAIN` - The domain where your app will be deployed (e.g., `localhost` for local dev)
- `COOKIE_SECRET` - Secret for encrypting session cookies (see "Generating New Secrets" section)
- `JWT_SECRET` - Secret for signing JWT tokens (see "Generating New Secrets" section)

#### Optional Variables:

- `XTDB_TOPOLOGY` - Database topology (default: `standalone`)
- `NREPL_PORT` - nREPL server port (default: `7888`)

### Generating New Secrets

The `config.env` file comes with pre-generated secrets that are fine for local development. For production deployment, you should generate new secrets.

**Option 1: Using OpenSSL (simplest, available on most systems)**

```bash
# Generate COOKIE_SECRET (16 bytes)
echo "COOKIE_SECRET=$(openssl rand -base64 16)"

# Generate JWT_SECRET (32 bytes)
echo "JWT_SECRET=$(openssl rand -base64 32)"
```

**Option 2: Using Python (if available)**

```bash
# Generate COOKIE_SECRET (16 bytes)
python3 -c "import secrets, base64; print('COOKIE_SECRET=' + base64.b64encode(secrets.token_bytes(16)).decode())"

# Generate JWT_SECRET (32 bytes)
python3 -c "import secrets, base64; print('JWT_SECRET=' + base64.b64encode(secrets.token_bytes(32)).decode())"
```

**Option 3: Using Docker (no additional tools needed)**

Generate secrets using the app's Docker container:

```bash
# Generate COOKIE_SECRET
docker compose run --rm app /opt/java/openjdk/bin/java -cp app.jar clojure.main -e \
  "(require '[com.biffweb :as biff]) \
   (println \"COOKIE_SECRET=\" (biff/base64-encode (biff/random-bytes 16)))"

# Generate JWT_SECRET
docker compose run --rm app /opt/java/openjdk/bin/java -cp app.jar clojure.main -e \
  "(require '[com.biffweb :as biff]) \
   (println \"JWT_SECRET=\" (biff/base64-encode (biff/random-bytes 32)))"
```

**Option 4: Using Clojure (if installed locally)**

```bash
clj -M:dev generate-secrets
```

Copy the generated values into your `config.env` file.

### Data Persistence

The application uses XTDB for data storage. By default, data is persisted in a Docker volume named `xtdb-data`.

To backup your data:
```bash
docker run --rm -v xtdb-data:/data -v $(pwd):/backup alpine tar czf /backup/xtdb-backup.tar.gz -C /data .
```

To restore from backup:
```bash
docker run --rm -v xtdb-data:/data -v $(pwd):/backup alpine sh -c "cd /data && tar xzf /backup/xtdb-backup.tar.gz"
```

## Performance Optimizations

This Docker setup implements the same performance optimizations as Biff's `server-setup.sh` nginx config:

### **Static Asset Serving**
- **Caddy serves static files directly** without hitting the Clojure app
- CSS, JavaScript, images, fonts served from `/var/www/public`
- Mirrors nginx's try_files behavior: static first, then proxy
- Significantly reduces load on the application server

### **Compression**
- **Gzip and Zstd compression** enabled for text-based assets
- Compresses CSS, JS, JSON, HTML, XML automatically
- Reduces bandwidth usage and improves load times

### **Caching Strategy**
- **Static assets cached for 1 year** (`max-age=31536000, immutable`)
- Browser won't re-request unchanged CSS/JS/images
- Cache-busting handled by Biff's asset pipeline (query string timestamps)

### **Benefits**
- âš¡ **Faster response times** - Static files served without JVM overhead
- ðŸ“‰ **Reduced memory usage** - Clojure app only handles dynamic requests
- ðŸš€ **Better scaling** - Caddy handles high static file throughput
- ðŸ’° **Lower costs** - Less CPU/memory needed on app server

## HTTPS Configuration

The application uses Caddy as a reverse proxy to provide HTTPS support out of the box.

### Architecture

```
Browser â”€â”€HTTPSâ”€â”€> Caddy (port 443) â”€â”€HTTPâ”€â”€> App (port 8080)
         (TLS)                               (internal)
```

### How It Works

1. **Caddy** listens on ports 80 (HTTP) and 443 (HTTPS)
2. Automatically generates **self-signed certificates** for localhost
3. Auto-redirects HTTP â†’ HTTPS
4. **Serves static files directly** (CSS, JS, images) from `/var/www/public`
5. **Proxies dynamic requests** to the app container on port 8080
6. **Enables compression** (gzip, zstd) for text assets
7. Sets proper headers (X-Forwarded-For, Cache-Control, etc.)

### Local Development

For local development, the self-signed certificate will trigger a browser warning:

1. Navigate to https://localhost
2. Browser shows "Your connection is not private" or similar
3. Click **"Advanced"** â†’ **"Proceed to localhost (unsafe)"**
4. This is **safe** for local development

### Production Deployment

For production with a real domain:

1. **Update Caddyfile** (replace `localhost` with your domain):

   The Caddyfile already includes a production template (commented out). Simply:
   - Replace `localhost {` with `yourdomain.com {`
   - Or copy the commented production example and update the domain

   The production config includes:
   - Static file serving from `/var/www/public`
   - Compression (gzip, zstd)
   - Cache headers for static assets
   - Reverse proxy to app for dynamic requests

2. **Caddy will automatically:**
   - Obtain real SSL certificates from Let's Encrypt
   - Handle certificate renewal
   - Serve static files efficiently
   - No browser warnings!

### Customizing Caddy

The `Caddyfile` configuration is mounted from the project root. Edit it to:
- Add custom domains
- Configure additional headers
- Add rate limiting
- Set up access logs
- Configure redirects

After editing, restart Caddy:
```bash
docker compose restart caddy
```

### Disabling HTTPS (Development Only)

If you need to disable HTTPS for debugging:

1. **Expose the app port directly in docker-compose.yml:**
   ```yaml
   app:
     ports:
       - "8080:8080"
   ```

2. **Stop Caddy:**
   ```bash
   docker compose stop caddy
   ```

3. **Access via HTTP:**
   http://localhost:8080

## Development Mode

For development, you might want to run with the dev profile:

```bash
docker run -d \
  --name apiary-app-dev \
  -p 8080:8080 \
  --env-file config.env \
  -e BIFF_PROFILE=dev \
  -e HOST=0.0.0.0 \
  -e PORT=8080 \
  apiary-app:latest
```

## Troubleshooting

### Container won't start

1. Check the logs:
   ```bash
   docker compose logs app
   ```

2. Verify environment variables:
   ```bash
   docker compose exec app env
   ```

### Port already in use

If port 8080 is already in use, modify `docker-compose.yml` to use a different port:
```yaml
ports:
  - "3000:8080"  # Access on port 3000 instead
```

### Database issues

If you encounter database issues, you can reset the database by removing the volume:
```bash
docker compose down -v
docker compose up -d
```

## Production Deployment

For production deployment:

1. **Update `config.env` with production values:**
   - Set `DOMAIN` to your actual domain (e.g., `myapp.com`)
   - **Generate new secrets** (see "Generating New Secrets" section above)
   - Set both `COOKIE_SECRET` and `JWT_SECRET` to the newly generated values

2. **Use PostgreSQL for XTDB (recommended for production):**
   ```env
   PROD_XTDB_TOPOLOGY=jdbc
   XTDB_JDBC_URL=jdbc:postgresql://host:port/dbname?user=alice&password=abc123&sslmode=require
   ```

3. **Build and deploy:**
   ```bash
   docker compose build
   docker compose up -d
   ```

4. **Verify deployment:**
   ```bash
   docker compose ps
   docker compose logs -f app
   ```

## Multi-Stage Build

The Dockerfile uses a multi-stage build to create a minimal production image:

1. **Stage 1 (jre-build):**
   - Uses `clojure:temurin-21-tools-deps-alpine` base image
   - Installs Tailwind CSS v3.4.17 for styling compilation
   - Builds the application uberjar using Clojure tools
   - Compiles all source, dev, test, and resources

2. **Stage 2 (runtime):**
   - Uses minimal `eclipse-temurin:21-alpine` base image
   - Copies only the compiled JAR file
   - Creates `/app/storage` directory for XTDB data
   - Declares volume for data persistence

This results in a smaller (~200MB), more secure production image.

## Health Checks

The application includes a health check that verifies the app is responding on port 8080. Docker will automatically restart the container if the health check fails.

## Networking

By default, the application listens on `0.0.0.0:8080` inside the container. You can customize this using environment variables:

```bash
-e HOST=0.0.0.0
-e PORT=8080
```

## Application Features

After deployment, the application provides:

- **Password-based authentication** - Secure BCrypt password hashing
- **Apiary summary management** - Track and manage beekeeping observations
- **AI-powered summaries** - Generate summaries from CSV imports using AI
- **XTDB database** - Temporal database with ACID guarantees
- **Responsive UI** - Tailwind CSS styling

## First-Time Setup

1. **Access the application:**
   Navigate to https://localhost (or http://localhost - will redirect to HTTPS)

   **Accept the security warning:**
   - Click "Advanced" â†’ "Proceed to localhost"
   - This is safe for local development with self-signed certificates

2. **Create your account:**
   - Click "Sign up"
   - Enter your email and password (minimum 8 characters)
   - Password is securely hashed using BCrypt

3. **Start using the app:**
   - You'll be redirected to `/summaries` after sign-in
   - Create manual summaries or import from CSV
   - Manage your apiary observations

## Technical Details

### Biff Framework Compliance

This Docker setup follows Biff framework best practices:

- âœ… `(:gen-class)` in main namespace for uberjar support
- âœ… `HOST=0.0.0.0` for Docker networking compatibility
- âœ… `PORT` environment variable for port configuration
- âœ… `BIFF_PROFILE` environment variable for dev/prod modes
- âœ… Multi-stage Alpine-based build for minimal image size
- âœ… Tailwind CSS integration for styling compilation
- âœ… XTDB data persistence via Docker volumes

### Build Details

- **Java Version:** 21 (Eclipse Temurin)
- **Clojure Tools:** tools-deps
- **Base OS:** Alpine Linux
- **Reverse Proxy:** Caddy 2.8 (automatic HTTPS)
- **Tailwind CSS:** v3.4.17
- **Database:** XTDB (standalone topology by default)
- **Password Security:** BCrypt with automatic salting
